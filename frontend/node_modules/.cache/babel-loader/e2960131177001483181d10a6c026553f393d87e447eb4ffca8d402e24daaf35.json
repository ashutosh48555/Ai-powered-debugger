{"ast":null,"code":"function Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var _options$timeout;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    var self = this;\n    function done(value) {\n      value = self.postProcess(value, options);\n      if (callback) {\n        setTimeout(function () {\n          callback(value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString, options);\n    newString = this.castInput(newString, options);\n    oldString = this.removeEmpty(this.tokenize(oldString, options));\n    newString = this.removeEmpty(this.tokenize(newString, options));\n    var newLen = newString.length,\n      oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    if (options.maxEditLength != null) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;\n    var abortAfterTimestamp = Date.now() + maxExecutionTime;\n    var bestPath = [{\n      oldPos: -1,\n      lastComponent: undefined\n    }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options);\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done(buildValues(self, bestPath[0].lastComponent, newString, oldString, self.useLongestToken));\n    }\n\n    // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n    var minDiagonalToConsider = -Infinity,\n      maxDiagonalToConsider = Infinity;\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n        var basePath = void 0;\n        var removePath = bestPath[diagonalPath - 1],\n          addPath = bestPath[diagonalPath + 1];\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n        var canAdd = false;\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          var addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n        var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {\n          basePath = self.addToPath(addPath, true, false, 0, options);\n        } else {\n          basePath = self.addToPath(removePath, false, true, 1, options);\n        }\n        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath, options);\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n        } else {\n          bestPath[diagonalPath] = basePath;\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback();\n          }\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        var ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  addToPath: function addToPath(path, added, removed, oldPosInc, options) {\n    var last = path.lastComponent;\n    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: last.count + 1,\n          added: added,\n          removed: removed,\n          previousComponent: last.previousComponent\n        }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: 1,\n          added: added,\n          removed: removed,\n          previousComponent: last\n        }\n      };\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath, options) {\n    var newLen = newString.length,\n      oldLen = oldString.length,\n      oldPos = basePath.oldPos,\n      newPos = oldPos - diagonalPath,\n      commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options)) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n      if (options.oneChangePerToken) {\n        basePath.lastComponent = {\n          count: 1,\n          previousComponent: basePath.lastComponent,\n          added: false,\n          removed: false\n        };\n      }\n    }\n    if (commonCount && !options.oneChangePerToken) {\n      basePath.lastComponent = {\n        count: commonCount,\n        previousComponent: basePath.lastComponent,\n        added: false,\n        removed: false\n      };\n    }\n    basePath.oldPos = oldPos;\n    return newPos;\n  },\n  equals: function equals(left, right, options) {\n    if (options.comparator) {\n      return options.comparator(left, right);\n    } else {\n      return left === right || options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return Array.from(value);\n  },\n  join: function join(chars) {\n    return chars.join('');\n  },\n  postProcess: function postProcess(changeObjects) {\n    return changeObjects;\n  }\n};\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n  // First we convert our linked list of components in reverse order to an\n  // array in the right order:\n  var components = [];\n  var nextComponent;\n  while (lastComponent) {\n    components.push(lastComponent);\n    nextComponent = lastComponent.previousComponent;\n    delete lastComponent.previousComponent;\n    lastComponent = nextComponent;\n  }\n  components.reverse();\n  var componentPos = 0,\n    componentLen = components.length,\n    newPos = 0,\n    oldPos = 0;\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n    }\n  }\n  return components;\n}\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\nfunction longestCommonPrefix(str1, str2) {\n  var i;\n  for (i = 0; i < str1.length && i < str2.length; i++) {\n    if (str1[i] != str2[i]) {\n      return str1.slice(0, i);\n    }\n  }\n  return str1.slice(0, i);\n}\nfunction longestCommonSuffix(str1, str2) {\n  var i;\n\n  // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n  // where we return the empty string since str1.slice(-0) will return the\n  // entire string.\n  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n    return '';\n  }\n  for (i = 0; i < str1.length && i < str2.length; i++) {\n    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n      return str1.slice(-i);\n    }\n  }\n  return str1.slice(-i);\n}\nfunction replacePrefix(string, oldPrefix, newPrefix) {\n  if (string.slice(0, oldPrefix.length) != oldPrefix) {\n    throw Error(\"string \".concat(JSON.stringify(string), \" doesn't start with prefix \").concat(JSON.stringify(oldPrefix), \"; this is a bug\"));\n  }\n  return newPrefix + string.slice(oldPrefix.length);\n}\nfunction replaceSuffix(string, oldSuffix, newSuffix) {\n  if (!oldSuffix) {\n    return string + newSuffix;\n  }\n  if (string.slice(-oldSuffix.length) != oldSuffix) {\n    throw Error(\"string \".concat(JSON.stringify(string), \" doesn't end with suffix \").concat(JSON.stringify(oldSuffix), \"; this is a bug\"));\n  }\n  return string.slice(0, -oldSuffix.length) + newSuffix;\n}\nfunction removePrefix(string, oldPrefix) {\n  return replacePrefix(string, oldPrefix, '');\n}\nfunction removeSuffix(string, oldSuffix) {\n  return replaceSuffix(string, oldSuffix, '');\n}\nfunction maximumOverlap(string1, string2) {\n  return string2.slice(0, overlapCount(string1, string2));\n}\n\n// Nicked from https://stackoverflow.com/a/60422853/1709587\nfunction overlapCount(a, b) {\n  // Deal with cases where the strings differ in length\n  var startA = 0;\n  if (a.length > b.length) {\n    startA = a.length - b.length;\n  }\n  var endB = b.length;\n  if (a.length < b.length) {\n    endB = a.length;\n  }\n  // Create a back-reference for each index\n  //   that should be followed in case of a mismatch.\n  //   We only need B to make these references:\n  var map = Array(endB);\n  var k = 0; // Index that lags behind j\n  map[0] = 0;\n  for (var j = 1; j < endB; j++) {\n    if (b[j] == b[k]) {\n      map[j] = map[k]; // skip over the same character (optional optimisation)\n    } else {\n      map[j] = k;\n    }\n    while (k > 0 && b[j] != b[k]) {\n      k = map[k];\n    }\n    if (b[j] == b[k]) {\n      k++;\n    }\n  }\n  // Phase 2: use these references while iterating over A\n  k = 0;\n  for (var i = startA; i < a.length; i++) {\n    while (k > 0 && a[i] != b[k]) {\n      k = map[k];\n    }\n    if (a[i] == b[k]) {\n      k++;\n    }\n  }\n  return k;\n}\n\n/**\n * Returns true if the string consistently uses Windows line endings.\n */\nfunction hasOnlyWinLineEndings(string) {\n  return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n}\n\n/**\n * Returns true if the string consistently uses Unix line endings.\n */\nfunction hasOnlyUnixLineEndings(string) {\n  return !string.includes('\\r\\n') && string.includes('\\n');\n}\n\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nvar extendedWordChars = \"a-zA-Z0-9_\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}\";\n\n// Each token is one of the following:\n// - A punctuation mark plus the surrounding whitespace\n// - A word plus the surrounding whitespace\n// - Pure whitespace (but only in the special case where this the entire text\n//   is just whitespace)\n//\n// We have to include surrounding whitespace in the tokens because the two\n// alternative approaches produce horribly broken results:\n// * If we just discard the whitespace, we can't fully reproduce the original\n//   text from the sequence of tokens and any attempt to render the diff will\n//   get the whitespace wrong.\n// * If we have separate tokens for whitespace, then in a typical text every\n//   second token will be a single space character. But this often results in\n//   the optimal diff between two texts being a perverse one that preserves\n//   the spaces between words but deletes and reinserts actual common words.\n//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n//   for an example.\n//\n// Keeping the surrounding whitespace of course has implications for .equals\n// and .join, not just .tokenize.\n\n// This regex does NOT fully implement the tokenization rules described above.\n// Instead, it gives runs of whitespace their own \"token\". The tokenize method\n// then handles stitching whitespace tokens onto adjacent word or punctuation\n// tokens.\nvar tokenizeIncludingWhitespace = new RegExp(\"[\".concat(extendedWordChars, \"]+|\\\\s+|[^\").concat(extendedWordChars, \"]\"), 'ug');\nvar wordDiff = new Diff();\nwordDiff.equals = function (left, right, options) {\n  if (options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n  return left.trim() === right.trim();\n};\nwordDiff.tokenize = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var parts;\n  if (options.intlSegmenter) {\n    if (options.intlSegmenter.resolvedOptions().granularity != 'word') {\n      throw new Error('The segmenter passed must have a granularity of \"word\"');\n    }\n    parts = Array.from(options.intlSegmenter.segment(value), function (segment) {\n      return segment.segment;\n    });\n  } else {\n    parts = value.match(tokenizeIncludingWhitespace) || [];\n  }\n  var tokens = [];\n  var prevPart = null;\n  parts.forEach(function (part) {\n    if (/\\s/.test(part)) {\n      if (prevPart == null) {\n        tokens.push(part);\n      } else {\n        tokens.push(tokens.pop() + part);\n      }\n    } else if (/\\s/.test(prevPart)) {\n      if (tokens[tokens.length - 1] == prevPart) {\n        tokens.push(tokens.pop() + part);\n      } else {\n        tokens.push(prevPart + part);\n      }\n    } else {\n      tokens.push(part);\n    }\n    prevPart = part;\n  });\n  return tokens;\n};\nwordDiff.join = function (tokens) {\n  // Tokens being joined here will always have appeared consecutively in the\n  // same text, so we can simply strip off the leading whitespace from all the\n  // tokens except the first (and except any whitespace-only tokens - but such\n  // a token will always be the first and only token anyway) and then join them\n  // and the whitespace around words and punctuation will end up correct.\n  return tokens.map(function (token, i) {\n    if (i == 0) {\n      return token;\n    } else {\n      return token.replace(/^\\s+/, '');\n    }\n  }).join('');\n};\nwordDiff.postProcess = function (changes, options) {\n  if (!changes || options.oneChangePerToken) {\n    return changes;\n  }\n  var lastKeep = null;\n  // Change objects representing any insertion or deletion since the last\n  // \"keep\" change object. There can be at most one of each.\n  var insertion = null;\n  var deletion = null;\n  changes.forEach(function (change) {\n    if (change.added) {\n      insertion = change;\n    } else if (change.removed) {\n      deletion = change;\n    } else {\n      if (insertion || deletion) {\n        // May be false at start of text\n        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n      }\n      lastKeep = change;\n      insertion = null;\n      deletion = null;\n    }\n  });\n  if (insertion || deletion) {\n    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n  }\n  return changes;\n};\nfunction diffWords(oldStr, newStr, options) {\n  // This option has never been documented and never will be (it's clearer to\n  // just call `diffWordsWithSpace` directly if you need that behavior), but\n  // has existed in jsdiff for a long time, so we retain support for it here\n  // for the sake of backwards compatibility.\n  if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {\n    return diffWordsWithSpace(oldStr, newStr, options);\n  }\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n  // Before returning, we tidy up the leading and trailing whitespace of the\n  // change objects to eliminate cases where trailing whitespace in one object\n  // is repeated as leading whitespace in the next.\n  // Below are examples of the outcomes we want here to explain the code.\n  // I=insert, K=keep, D=delete\n  // 1. diffing 'foo bar baz' vs 'foo baz'\n  //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n  //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n  //\n  // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n  //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n  //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n  //\n  // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n  //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n  //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n  //\n  // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n  //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n  //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n  //    but don't actually manage this currently (the pre-cleanup change\n  //    objects don't contain enough information to make it possible).\n  //\n  // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n  //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n  //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n  //\n  // Our handling is unavoidably imperfect in the case where there's a single\n  // indel between keeps and the whitespace has changed. For instance, consider\n  // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n  // object to represent the insertion of the space character (which isn't even\n  // a token), we have no way to avoid losing information about the texts'\n  // original whitespace in the result we return. Still, we do our best to\n  // output something that will look sensible if we e.g. print it with\n  // insertions in green and deletions in red.\n\n  // Between two \"keep\" change objects (or before the first or after the last\n  // change object), we can have either:\n  // * A \"delete\" followed by an \"insert\"\n  // * Just an \"insert\"\n  // * Just a \"delete\"\n  // We handle the three cases separately.\n  if (deletion && insertion) {\n    var oldWsPrefix = deletion.value.match(/^\\s*/)[0];\n    var oldWsSuffix = deletion.value.match(/\\s*$/)[0];\n    var newWsPrefix = insertion.value.match(/^\\s*/)[0];\n    var newWsSuffix = insertion.value.match(/\\s*$/)[0];\n    if (startKeep) {\n      var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n      deletion.value = removePrefix(deletion.value, commonWsPrefix);\n      insertion.value = removePrefix(insertion.value, commonWsPrefix);\n    }\n    if (endKeep) {\n      var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n      deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n      insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n    }\n  } else if (insertion) {\n    // The whitespaces all reflect what was in the new text rather than\n    // the old, so we essentially have no information about whitespace\n    // insertion or deletion. We just want to dedupe the whitespace.\n    // We do that by having each change object keep its trailing\n    // whitespace and deleting duplicate leading whitespace where\n    // present.\n    if (startKeep) {\n      insertion.value = insertion.value.replace(/^\\s*/, '');\n    }\n    if (endKeep) {\n      endKeep.value = endKeep.value.replace(/^\\s*/, '');\n    }\n    // otherwise we've got a deletion and no insertion\n  } else if (startKeep && endKeep) {\n    var newWsFull = endKeep.value.match(/^\\s*/)[0],\n      delWsStart = deletion.value.match(/^\\s*/)[0],\n      delWsEnd = deletion.value.match(/\\s*$/)[0];\n\n    // Any whitespace that comes straight after startKeep in both the old and\n    // new texts, assign to startKeep and remove from the deletion.\n    var newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n    deletion.value = removePrefix(deletion.value, newWsStart);\n\n    // Any whitespace that comes straight before endKeep in both the old and\n    // new texts, and hasn't already been assigned to startKeep, assign to\n    // endKeep and remove from the deletion.\n    var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);\n    deletion.value = removeSuffix(deletion.value, newWsEnd);\n    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n\n    // If there's any whitespace from the new text that HASN'T already been\n    // assigned, assign it to the start:\n    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));\n  } else if (endKeep) {\n    // We are at the start of the text. Preserve all the whitespace on\n    // endKeep, and just remove whitespace from the end of deletion to the\n    // extent that it overlaps with the start of endKeep.\n    var endKeepWsPrefix = endKeep.value.match(/^\\s*/)[0];\n    var deletionWsSuffix = deletion.value.match(/\\s*$/)[0];\n    var overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n    deletion.value = removeSuffix(deletion.value, overlap);\n  } else if (startKeep) {\n    // We are at the END of the text. Preserve all the whitespace on\n    // startKeep, and just remove whitespace from the start of deletion to\n    // the extent that it overlaps with the end of startKeep.\n    var startKeepWsSuffix = startKeep.value.match(/\\s*$/)[0];\n    var deletionWsPrefix = deletion.value.match(/^\\s*/)[0];\n    var _overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n    deletion.value = removePrefix(deletion.value, _overlap);\n  }\n}\nvar wordWithSpaceDiff = new Diff();\nwordWithSpaceDiff.tokenize = function (value) {\n  // Slightly different to the tokenizeIncludingWhitespace regex used above in\n  // that this one treats each individual newline as a distinct tokens, rather\n  // than merging them into other surrounding whitespace. This was requested\n  // in https://github.com/kpdecker/jsdiff/issues/180 &\n  //    https://github.com/kpdecker/jsdiff/issues/211\n  var regex = new RegExp(\"(\\\\r?\\\\n)|[\".concat(extendedWordChars, \"]+|[^\\\\S\\\\n\\\\r]+|[^\").concat(extendedWordChars, \"]\"), 'ug');\n  return value.match(regex) || [];\n};\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordWithSpaceDiff.diff(oldStr, newStr, options);\n}\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n  return defaults;\n}\nvar lineDiff = new Diff();\nlineDiff.tokenize = function (value, options) {\n  if (options.stripTrailingCr) {\n    // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n    value = value.replace(/\\r\\n/g, '\\n');\n  }\n  var retLines = [],\n    linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n  // Ignore the final empty token that occurs if the string ends with a new line\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  }\n\n  // Merge the content and line separators into single tokens\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n    if (i % 2 && !options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      retLines.push(line);\n    }\n  }\n  return retLines;\n};\nlineDiff.equals = function (left, right, options) {\n  // If we're ignoring whitespace, we need to normalise lines by stripping\n  // whitespace before checking equality. (This has an annoying interaction\n  // with newlineIsToken that requires special handling: if newlines get their\n  // own token, then we DON'T want to trim the *newline* tokens down to empty\n  // strings, since this would cause us to treat whitespace-only line content\n  // as equal to a separator between lines, which would be weird and\n  // inconsistent with the documented behavior of the options.)\n  if (options.ignoreWhitespace) {\n    if (!options.newlineIsToken || !left.includes('\\n')) {\n      left = left.trim();\n    }\n    if (!options.newlineIsToken || !right.includes('\\n')) {\n      right = right.trim();\n    }\n  } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {\n    if (left.endsWith('\\n')) {\n      left = left.slice(0, -1);\n    }\n    if (right.endsWith('\\n')) {\n      right = right.slice(0, -1);\n    }\n  }\n  return Diff.prototype.equals.call(this, left, right, options);\n};\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\n\n// Kept for backwards compatibility. This is a rather arbitrary wrapper method\n// that just calls `diffLines` with `ignoreWhitespace: true`. It's confusing to\n// have two ways to do exactly the same thing in the API, so we no longer\n// document this one (library users should explicitly use `diffLines` with\n// `ignoreWhitespace: true` instead) but we keep it around to maintain\n// compatibility with code that used old versions.\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\nvar sentenceDiff = new Diff();\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\nvar cssDiff = new Diff();\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar jsonDiff = new Diff();\n// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function (value, options) {\n  var undefinedReplacement = options.undefinedReplacement,\n    _options$stringifyRep = options.stringifyReplacer,\n    stringifyReplacer = _options$stringifyRep === void 0 ? function (k, v) {\n      return typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _options$stringifyRep;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\njsonDiff.equals = function (left, right, options) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'), options);\n};\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n}\n\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n  var i;\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n  var canonicalizedObj;\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    var sortedKeys = [],\n      _key;\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (Object.prototype.hasOwnProperty.call(obj, _key)) {\n        sortedKeys.push(_key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}\nvar arrayDiff = new Diff();\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\nfunction unixToWin(patch) {\n  if (Array.isArray(patch)) {\n    return patch.map(unixToWin);\n  }\n  return _objectSpread2(_objectSpread2({}, patch), {}, {\n    hunks: patch.hunks.map(function (hunk) {\n      return _objectSpread2(_objectSpread2({}, hunk), {}, {\n        lines: hunk.lines.map(function (line, i) {\n          var _hunk$lines;\n          return line.startsWith('\\\\') || line.endsWith('\\r') || (_hunk$lines = hunk.lines[i + 1]) !== null && _hunk$lines !== void 0 && _hunk$lines.startsWith('\\\\') ? line : line + '\\r';\n        })\n      });\n    })\n  });\n}\nfunction winToUnix(patch) {\n  if (Array.isArray(patch)) {\n    return patch.map(winToUnix);\n  }\n  return _objectSpread2(_objectSpread2({}, patch), {}, {\n    hunks: patch.hunks.map(function (hunk) {\n      return _objectSpread2(_objectSpread2({}, hunk), {}, {\n        lines: hunk.lines.map(function (line) {\n          return line.endsWith('\\r') ? line.substring(0, line.length - 1) : line;\n        })\n      });\n    })\n  });\n}\n\n/**\n * Returns true if the patch consistently uses Unix line endings (or only involves one line and has\n * no line endings).\n */\nfunction isUnix(patch) {\n  if (!Array.isArray(patch)) {\n    patch = [patch];\n  }\n  return !patch.some(function (index) {\n    return index.hunks.some(function (hunk) {\n      return hunk.lines.some(function (line) {\n        return !line.startsWith('\\\\') && line.endsWith('\\r');\n      });\n    });\n  });\n}\n\n/**\n * Returns true if the patch uses Windows line endings and only Windows line endings.\n */\nfunction isWin(patch) {\n  if (!Array.isArray(patch)) {\n    patch = [patch];\n  }\n  return patch.some(function (index) {\n    return index.hunks.some(function (hunk) {\n      return hunk.lines.some(function (line) {\n        return line.endsWith('\\r');\n      });\n    });\n  }) && patch.every(function (index) {\n    return index.hunks.every(function (hunk) {\n      return hunk.lines.every(function (line, i) {\n        var _hunk$lines2;\n        return line.startsWith('\\\\') || line.endsWith('\\r') || ((_hunk$lines2 = hunk.lines[i + 1]) === null || _hunk$lines2 === void 0 ? void 0 : _hunk$lines2.startsWith('\\\\'));\n      });\n    });\n  });\n}\nfunction parsePatch(uniDiff) {\n  var diffstr = uniDiff.split(/\\n/),\n    list = [],\n    i = 0;\n  function parseIndex() {\n    var index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      var line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      }\n\n      // Diff index\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n      if (/^(Index:\\s|diff\\s|\\-\\-\\-\\s|\\+\\+\\+\\s|===================================================================)/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line) {\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)\\r?$/.exec(diffstr[i]);\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n      chunkHeaderLine = diffstr[i++],\n      chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: []\n    };\n\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n    var addCount = 0,\n      removeCount = 0;\n    for (; i < diffstr.length && (removeCount < hunk.oldLines || addCount < hunk.newLines || (_diffstr$i = diffstr[i]) !== null && _diffstr$i !== void 0 && _diffstr$i.startsWith('\\\\')); i++) {\n      var _diffstr$i;\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        throw new Error(\"Hunk at line \".concat(chunkHeaderIndex + 1, \" contained invalid line \").concat(diffstr[i]));\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform sanity checking\n    if (addCount !== hunk.newLines) {\n      throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n    }\n    if (removeCount !== hunk.oldLines) {\n      throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n    }\n    return hunk;\n  }\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n  return list;\n}\n\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator(start, minLine, maxLine) {\n  var wantForward = true,\n    backwardExhausted = false,\n    forwardExhausted = false,\n    localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      }\n\n      // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n      if (start + localOffset <= maxLine) {\n        return start + localOffset;\n      }\n      forwardExhausted = true;\n    }\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      }\n\n      // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n      if (minLine <= start - localOffset) {\n        return start - localOffset++;\n      }\n      backwardExhausted = true;\n      return iterator();\n    }\n\n    // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n  };\n}\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n    uniDiff = uniDiff[0];\n  }\n  if (options.autoConvertLineEndings || options.autoConvertLineEndings == null) {\n    if (hasOnlyWinLineEndings(source) && isUnix(uniDiff)) {\n      uniDiff = unixToWin(uniDiff);\n    } else if (hasOnlyUnixLineEndings(source) && isWin(uniDiff)) {\n      uniDiff = winToUnix(uniDiff);\n    }\n  }\n\n  // Apply the diff to the input\n  var lines = source.split('\\n'),\n    hunks = uniDiff.hunks,\n    compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n      return line === patchContent;\n    },\n    fuzzFactor = options.fuzzFactor || 0,\n    minLine = 0;\n  if (fuzzFactor < 0 || !Number.isInteger(fuzzFactor)) {\n    throw new Error('fuzzFactor must be a non-negative integer');\n  }\n\n  // Special case for empty patch.\n  if (!hunks.length) {\n    return source;\n  }\n\n  // Before anything else, handle EOFNL insertion/removal. If the patch tells us to make a change\n  // to the EOFNL that is redundant/impossible - i.e. to remove a newline that's not there, or add a\n  // newline that already exists - then we either return false and fail to apply the patch (if\n  // fuzzFactor is 0) or simply ignore the problem and do nothing (if fuzzFactor is >0).\n  // If we do need to remove/add a newline at EOF, this will always be in the final hunk:\n  var prevLine = '',\n    removeEOFNL = false,\n    addEOFNL = false;\n  for (var i = 0; i < hunks[hunks.length - 1].lines.length; i++) {\n    var line = hunks[hunks.length - 1].lines[i];\n    if (line[0] == '\\\\') {\n      if (prevLine[0] == '+') {\n        removeEOFNL = true;\n      } else if (prevLine[0] == '-') {\n        addEOFNL = true;\n      }\n    }\n    prevLine = line;\n  }\n  if (removeEOFNL) {\n    if (addEOFNL) {\n      // This means the final line gets changed but doesn't have a trailing newline in either the\n      // original or patched version. In that case, we do nothing if fuzzFactor > 0, and if\n      // fuzzFactor is 0, we simply validate that the source file has no trailing newline.\n      if (!fuzzFactor && lines[lines.length - 1] == '') {\n        return false;\n      }\n    } else if (lines[lines.length - 1] == '') {\n      lines.pop();\n    } else if (!fuzzFactor) {\n      return false;\n    }\n  } else if (addEOFNL) {\n    if (lines[lines.length - 1] != '') {\n      lines.push('');\n    } else if (!fuzzFactor) {\n      return false;\n    }\n  }\n\n  /**\n   * Checks if the hunk can be made to fit at the provided location with at most `maxErrors`\n   * insertions, substitutions, or deletions, while ensuring also that:\n   * - lines deleted in the hunk match exactly, and\n   * - wherever an insertion operation or block of insertion operations appears in the hunk, the\n   *   immediately preceding and following lines of context match exactly\n   *\n   * `toPos` should be set such that lines[toPos] is meant to match hunkLines[0].\n   *\n   * If the hunk can be applied, returns an object with properties `oldLineLastI` and\n   * `replacementLines`. Otherwise, returns null.\n   */\n  function applyHunk(hunkLines, toPos, maxErrors) {\n    var hunkLinesI = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var lastContextLineMatched = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var patchedLines = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n    var patchedLinesLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var nConsecutiveOldContextLines = 0;\n    var nextContextLineMustMatch = false;\n    for (; hunkLinesI < hunkLines.length; hunkLinesI++) {\n      var hunkLine = hunkLines[hunkLinesI],\n        operation = hunkLine.length > 0 ? hunkLine[0] : ' ',\n        content = hunkLine.length > 0 ? hunkLine.substr(1) : hunkLine;\n      if (operation === '-') {\n        if (compareLine(toPos + 1, lines[toPos], operation, content)) {\n          toPos++;\n          nConsecutiveOldContextLines = 0;\n        } else {\n          if (!maxErrors || lines[toPos] == null) {\n            return null;\n          }\n          patchedLines[patchedLinesLength] = lines[toPos];\n          return applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1);\n        }\n      }\n      if (operation === '+') {\n        if (!lastContextLineMatched) {\n          return null;\n        }\n        patchedLines[patchedLinesLength] = content;\n        patchedLinesLength++;\n        nConsecutiveOldContextLines = 0;\n        nextContextLineMustMatch = true;\n      }\n      if (operation === ' ') {\n        nConsecutiveOldContextLines++;\n        patchedLines[patchedLinesLength] = lines[toPos];\n        if (compareLine(toPos + 1, lines[toPos], operation, content)) {\n          patchedLinesLength++;\n          lastContextLineMatched = true;\n          nextContextLineMustMatch = false;\n          toPos++;\n        } else {\n          if (nextContextLineMustMatch || !maxErrors) {\n            return null;\n          }\n\n          // Consider 3 possibilities in sequence:\n          // 1. lines contains a *substitution* not included in the patch context, or\n          // 2. lines contains an *insertion* not included in the patch context, or\n          // 3. lines contains a *deletion* not included in the patch context\n          // The first two options are of course only possible if the line from lines is non-null -\n          // i.e. only option 3 is possible if we've overrun the end of the old file.\n          return lines[toPos] && (applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength + 1) || applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1)) || applyHunk(hunkLines, toPos, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength);\n        }\n      }\n    }\n\n    // Before returning, trim any unmodified context lines off the end of patchedLines and reduce\n    // toPos (and thus oldLineLastI) accordingly. This allows later hunks to be applied to a region\n    // that starts in this hunk's trailing context.\n    patchedLinesLength -= nConsecutiveOldContextLines;\n    toPos -= nConsecutiveOldContextLines;\n    patchedLines.length = patchedLinesLength;\n    return {\n      patchedLines: patchedLines,\n      oldLineLastI: toPos - 1\n    };\n  }\n  var resultLines = [];\n\n  // Search best fit offsets for each hunk based on the previous ones\n  var prevHunkOffset = 0;\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var hunk = hunks[_i];\n    var hunkResult = void 0;\n    var maxLine = lines.length - hunk.oldLines + fuzzFactor;\n    var toPos = void 0;\n    for (var maxErrors = 0; maxErrors <= fuzzFactor; maxErrors++) {\n      toPos = hunk.oldStart + prevHunkOffset - 1;\n      var iterator = distanceIterator(toPos, minLine, maxLine);\n      for (; toPos !== undefined; toPos = iterator()) {\n        hunkResult = applyHunk(hunk.lines, toPos, maxErrors);\n        if (hunkResult) {\n          break;\n        }\n      }\n      if (hunkResult) {\n        break;\n      }\n    }\n    if (!hunkResult) {\n      return false;\n    }\n\n    // Copy everything from the end of where we applied the last hunk to the start of this hunk\n    for (var _i2 = minLine; _i2 < toPos; _i2++) {\n      resultLines.push(lines[_i2]);\n    }\n\n    // Add the lines produced by applying the hunk:\n    for (var _i3 = 0; _i3 < hunkResult.patchedLines.length; _i3++) {\n      var _line = hunkResult.patchedLines[_i3];\n      resultLines.push(_line);\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunkResult.oldLineLastI + 1;\n\n    // Note the offset between where the patch said the hunk should've applied and where we\n    // applied it, so we can adjust future hunks accordingly:\n    prevHunkOffset = toPos + 1 - hunk.oldStart;\n  }\n\n  // Copy over the rest of the lines from the old text\n  for (var _i4 = minLine; _i4 < lines.length; _i4++) {\n    resultLines.push(lines[_i4]);\n  }\n  return resultLines.join('\\n');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n  var currentIndex = 0;\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options === 'function') {\n    options = {\n      callback: options\n    };\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n  if (options.newlineIsToken) {\n    throw new Error('newlineIsToken may not be used with patch-generation functions, only with diffing functions');\n  }\n  if (!options.callback) {\n    return diffLinesResultToPatch(diffLines(oldStr, newStr, options));\n  } else {\n    var _options = options,\n      _callback = _options.callback;\n    diffLines(oldStr, newStr, _objectSpread2(_objectSpread2({}, options), {}, {\n      callback: function callback(diff) {\n        var patch = diffLinesResultToPatch(diff);\n        _callback(patch);\n      }\n    }));\n  }\n  function diffLinesResultToPatch(diff) {\n    // STEP 1: Build up the patch with no \"\\ No newline at end of file\" lines and with the arrays\n    //         of lines containing trailing newline characters. We'll tidy up later...\n\n    if (!diff) {\n      return;\n    }\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n    var hunks = [];\n    var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n    var _loop = function _loop() {\n      var current = diff[i],\n        lines = current.lines || splitLines(current.value);\n      current.lines = lines;\n      if (current.added || current.removed) {\n        var _curRange;\n        // If we have previous context, start with that\n        if (!oldRangeStart) {\n          var prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        }\n\n        // Output our changes\n        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n          return (current.added ? '+' : '-') + entry;\n        })));\n\n        // Track the updated file position\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            var _curRange2;\n            // Overlapping\n            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n          } else {\n            var _curRange3;\n            // end the range and output\n            var contextSize = Math.min(lines.length, options.context);\n            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n            var _hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n            hunks.push(_hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    };\n    for (var i = 0; i < diff.length; i++) {\n      _loop();\n    }\n\n    // Step 2: eliminate the trailing `\\n` from each line of each hunk, and, where needed, add\n    //         \"\\ No newline at end of file\".\n    for (var _i = 0, _hunks = hunks; _i < _hunks.length; _i++) {\n      var hunk = _hunks[_i];\n      for (var _i2 = 0; _i2 < hunk.lines.length; _i2++) {\n        if (hunk.lines[_i2].endsWith('\\n')) {\n          hunk.lines[_i2] = hunk.lines[_i2].slice(0, -1);\n        } else {\n          hunk.lines.splice(_i2 + 1, 0, '\\\\ No newline at end of file');\n          _i2++; // Skip the line we just added, then continue iterating\n        }\n      }\n    }\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n}\nfunction formatPatch(diff) {\n  if (Array.isArray(diff)) {\n    return diff.map(formatPatch).join('\\n');\n  }\n  var ret = [];\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i];\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n  return ret.join('\\n') + '\\n';\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  var _options2;\n  if (typeof options === 'function') {\n    options = {\n      callback: options\n    };\n  }\n  if (!((_options2 = options) !== null && _options2 !== void 0 && _options2.callback)) {\n    var patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n    if (!patchObj) {\n      return;\n    }\n    return formatPatch(patchObj);\n  } else {\n    var _options3 = options,\n      _callback2 = _options3.callback;\n    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, _objectSpread2(_objectSpread2({}, options), {}, {\n      callback: function callback(patchObj) {\n        if (!patchObj) {\n          _callback2();\n        } else {\n          _callback2(formatPatch(patchObj));\n        }\n      }\n    }));\n  }\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\n/**\n * Split `text` into an array of lines, including the trailing newline character (where present)\n */\nfunction splitLines(text) {\n  var hasTrailingNl = text.endsWith('\\n');\n  var result = text.split('\\n').map(function (line) {\n    return line + '\\n';\n  });\n  if (hasTrailingNl) {\n    result.pop();\n  } else {\n    result.push(result.pop().slice(0, -1));\n  }\n  return result;\n}\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n    oldLines = _calcOldNewLineCount.oldLines,\n    newLines = _calcOldNewLineCount.newLines;\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n  ret.hunks = [];\n  var mineIndex = 0,\n    theirsIndex = 0,\n    mineOffset = 0,\n    theirsOffset = 0;\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n      theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n  return ret;\n}\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n  return param;\n}\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n    their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    };\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n      theirCurrent = their.lines[their.index];\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines;\n      // Mine inserted\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2;\n      // Theirs inserted\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n    theirChanges = collectChange(their);\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n    return;\n  }\n  conflict(hunk, myChanges, theirChanges);\n}\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n    theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\nfunction collectChange(state) {\n  var ret = [],\n    operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n    merged = [],\n    matchIndex = 0,\n    contextChanges = false,\n    conflicted = false;\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n      match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n  if (conflicted) {\n    return changes;\n  }\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n  state.index += delta;\n  return true;\n}\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\nfunction reversePatch(structuredPatch) {\n  if (Array.isArray(structuredPatch)) {\n    return structuredPatch.map(reversePatch).reverse();\n  }\n  return _objectSpread2(_objectSpread2({}, structuredPatch), {}, {\n    oldFileName: structuredPatch.newFileName,\n    oldHeader: structuredPatch.newHeader,\n    newFileName: structuredPatch.oldFileName,\n    newHeader: structuredPatch.oldHeader,\n    hunks: structuredPatch.hunks.map(function (hunk) {\n      return {\n        oldLines: hunk.newLines,\n        oldStart: hunk.newStart,\n        newLines: hunk.oldLines,\n        newStart: hunk.oldStart,\n        lines: hunk.lines.map(function (l) {\n          if (l.startsWith('-')) {\n            return \"+\".concat(l.slice(1));\n          }\n          if (l.startsWith('+')) {\n            return \"-\".concat(l.slice(1));\n          }\n          return l;\n        })\n      };\n    })\n  });\n}\n\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n    change,\n    operation;\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n    ret.push([operation, change.value]);\n  }\n  return ret;\n}\nfunction convertChangesToXML(changes) {\n  var ret = [];\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n    ret.push(escapeHTML(change.value));\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n  return ret.join('');\n}\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, formatPatch, merge, parsePatch, reversePatch, structuredPatch };","map":{"version":3,"names":["Diff","prototype","diff","oldString","newString","_options$timeout","options","arguments","length","undefined","callback","self","done","value","postProcess","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","Math","min","maxExecutionTime","timeout","Infinity","abortAfterTimestamp","Date","now","bestPath","oldPos","lastComponent","newPos","extractCommon","buildValues","useLongestToken","minDiagonalToConsider","maxDiagonalToConsider","execEditLength","diagonalPath","max","basePath","removePath","addPath","canAdd","addPathNewPos","canRemove","addToPath","exec","ret","path","added","removed","oldPosInc","last","oneChangePerToken","count","previousComponent","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","push","Array","from","join","chars","changeObjects","components","nextComponent","reverse","componentPos","componentLen","component","slice","map","oldValue","characterDiff","diffChars","oldStr","newStr","longestCommonPrefix","str1","str2","longestCommonSuffix","replacePrefix","string","oldPrefix","newPrefix","Error","concat","JSON","stringify","replaceSuffix","oldSuffix","newSuffix","removePrefix","removeSuffix","maximumOverlap","string1","string2","overlapCount","a","b","startA","endB","k","j","hasOnlyWinLineEndings","includes","startsWith","match","hasOnlyUnixLineEndings","extendedWordChars","tokenizeIncludingWhitespace","RegExp","wordDiff","trim","parts","intlSegmenter","resolvedOptions","granularity","segment","tokens","prevPart","forEach","part","test","pop","token","replace","changes","lastKeep","insertion","deletion","change","dedupeWhitespaceInChangeObjects","diffWords","ignoreWhitespace","diffWordsWithSpace","startKeep","endKeep","oldWsPrefix","oldWsSuffix","newWsPrefix","newWsSuffix","commonWsPrefix","commonWsSuffix","newWsFull","delWsStart","delWsEnd","newWsStart","newWsEnd","endKeepWsPrefix","deletionWsSuffix","overlap","startKeepWsSuffix","deletionWsPrefix","_overlap","wordWithSpaceDiff","regex","generateOptions","defaults","name","hasOwnProperty","lineDiff","stripTrailingCr","retLines","linesAndNewlines","split","line","newlineIsToken","ignoreNewlineAtEof","endsWith","call","diffLines","diffTrimmedLines","sentenceDiff","diffSentences","cssDiff","diffCss","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","apply","_objectSpread2","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","_toPropertyKey","_typeof","iterator","constructor","obj","key","configurable","writable","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","isArray","_arrayLikeToArray","iter","minLen","n","toString","len","arr2","jsonDiff","undefinedReplacement","_options$stringifyRep","stringifyReplacer","v","canonicalize","diffJson","oldObj","newObj","stack","replacementStack","replacer","canonicalizedObj","toJSON","sortedKeys","_key","sort","arrayDiff","diffArrays","oldArr","newArr","unixToWin","patch","hunks","hunk","lines","_hunk$lines","winToUnix","substring","isUnix","some","index","isWin","every","_hunk$lines2","parsePatch","uniDiff","diffstr","list","parseIndex","header","parseFileHeader","_line","parseHunk","fileHeader","keyPrefix","data","fileName","substr","chunkHeaderIndex","chunkHeaderLine","chunkHeader","oldStart","oldLines","newStart","newLines","addCount","removeCount","_diffstr$i","operation","distanceIterator","start","minLine","maxLine","wantForward","backwardExhausted","forwardExhausted","localOffset","applyPatch","source","autoConvertLineEndings","compareLine","lineNumber","patchContent","fuzzFactor","isInteger","prevLine","removeEOFNL","addEOFNL","applyHunk","hunkLines","toPos","maxErrors","hunkLinesI","lastContextLineMatched","patchedLines","patchedLinesLength","nConsecutiveOldContextLines","nextContextLineMustMatch","hunkLine","content","oldLineLastI","resultLines","prevHunkOffset","_i","hunkResult","_i2","_i3","_i4","applyPatches","currentIndex","processIndex","complete","loadFile","err","updatedContent","patched","structuredPatch","oldFileName","newFileName","oldHeader","newHeader","context","diffLinesResultToPatch","_options","_callback","contextLines","entry","oldRangeStart","newRangeStart","curRange","oldLine","newLine","_loop","current","splitLines","_curRange","prev","_curRange2","_curRange3","contextSize","_hunk","_hunks","splice","formatPatch","createTwoFilesPatch","_options2","patchObj","_options3","_callback2","createPatch","text","hasTrailingNl","result","arrayEqual","arrayStartsWith","calcLineCount","_calcOldNewLineCount","calcOldNewLineCount","merge","mine","theirs","base","loadPatch","fileNameChanged","selectField","mineIndex","theirsIndex","mineOffset","theirsOffset","mineCurrent","theirsCurrent","hunkBefore","cloneHunk","mergedHunk","mergeLines","param","conflict","check","offset","mineLines","theirOffset","theirLines","their","insertLeading","theirCurrent","mutualChange","collectChange","removal","insertTrailing","myChanges","theirChanges","allRemoves","skipRemoveSuperset","_hunk$lines3","_hunk$lines4","_hunk$lines5","swap","collectContext","merged","_hunk$lines6","insert","state","matchChanges","matchIndex","contextChanges","conflicted","reduce","removeChanges","delta","changeContent","myCount","theirCount","reversePatch","l","convertChangesToDMP","convertChangesToXML","escapeHTML","s"],"sources":["E:/Code Debugger/ai-powered-debugger/frontend/node_modules/diff/lib/index.mjs"],"sourcesContent":["function Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var _options$timeout;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    var self = this;\n    function done(value) {\n      value = self.postProcess(value, options);\n      if (callback) {\n        setTimeout(function () {\n          callback(value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString, options);\n    newString = this.castInput(newString, options);\n    oldString = this.removeEmpty(this.tokenize(oldString, options));\n    newString = this.removeEmpty(this.tokenize(newString, options));\n    var newLen = newString.length,\n      oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    if (options.maxEditLength != null) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;\n    var abortAfterTimestamp = Date.now() + maxExecutionTime;\n    var bestPath = [{\n      oldPos: -1,\n      lastComponent: undefined\n    }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options);\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done(buildValues(self, bestPath[0].lastComponent, newString, oldString, self.useLongestToken));\n    }\n\n    // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n    var minDiagonalToConsider = -Infinity,\n      maxDiagonalToConsider = Infinity;\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n        var basePath = void 0;\n        var removePath = bestPath[diagonalPath - 1],\n          addPath = bestPath[diagonalPath + 1];\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n        var canAdd = false;\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          var addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n        var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {\n          basePath = self.addToPath(addPath, true, false, 0, options);\n        } else {\n          basePath = self.addToPath(removePath, false, true, 1, options);\n        }\n        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath, options);\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n        } else {\n          bestPath[diagonalPath] = basePath;\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback();\n          }\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        var ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  addToPath: function addToPath(path, added, removed, oldPosInc, options) {\n    var last = path.lastComponent;\n    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: last.count + 1,\n          added: added,\n          removed: removed,\n          previousComponent: last.previousComponent\n        }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: 1,\n          added: added,\n          removed: removed,\n          previousComponent: last\n        }\n      };\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath, options) {\n    var newLen = newString.length,\n      oldLen = oldString.length,\n      oldPos = basePath.oldPos,\n      newPos = oldPos - diagonalPath,\n      commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options)) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n      if (options.oneChangePerToken) {\n        basePath.lastComponent = {\n          count: 1,\n          previousComponent: basePath.lastComponent,\n          added: false,\n          removed: false\n        };\n      }\n    }\n    if (commonCount && !options.oneChangePerToken) {\n      basePath.lastComponent = {\n        count: commonCount,\n        previousComponent: basePath.lastComponent,\n        added: false,\n        removed: false\n      };\n    }\n    basePath.oldPos = oldPos;\n    return newPos;\n  },\n  equals: function equals(left, right, options) {\n    if (options.comparator) {\n      return options.comparator(left, right);\n    } else {\n      return left === right || options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return Array.from(value);\n  },\n  join: function join(chars) {\n    return chars.join('');\n  },\n  postProcess: function postProcess(changeObjects) {\n    return changeObjects;\n  }\n};\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n  // First we convert our linked list of components in reverse order to an\n  // array in the right order:\n  var components = [];\n  var nextComponent;\n  while (lastComponent) {\n    components.push(lastComponent);\n    nextComponent = lastComponent.previousComponent;\n    delete lastComponent.previousComponent;\n    lastComponent = nextComponent;\n  }\n  components.reverse();\n  var componentPos = 0,\n    componentLen = components.length,\n    newPos = 0,\n    oldPos = 0;\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n    }\n  }\n  return components;\n}\n\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction longestCommonPrefix(str1, str2) {\n  var i;\n  for (i = 0; i < str1.length && i < str2.length; i++) {\n    if (str1[i] != str2[i]) {\n      return str1.slice(0, i);\n    }\n  }\n  return str1.slice(0, i);\n}\nfunction longestCommonSuffix(str1, str2) {\n  var i;\n\n  // Unlike longestCommonPrefix, we need a special case to handle all scenarios\n  // where we return the empty string since str1.slice(-0) will return the\n  // entire string.\n  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {\n    return '';\n  }\n  for (i = 0; i < str1.length && i < str2.length; i++) {\n    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {\n      return str1.slice(-i);\n    }\n  }\n  return str1.slice(-i);\n}\nfunction replacePrefix(string, oldPrefix, newPrefix) {\n  if (string.slice(0, oldPrefix.length) != oldPrefix) {\n    throw Error(\"string \".concat(JSON.stringify(string), \" doesn't start with prefix \").concat(JSON.stringify(oldPrefix), \"; this is a bug\"));\n  }\n  return newPrefix + string.slice(oldPrefix.length);\n}\nfunction replaceSuffix(string, oldSuffix, newSuffix) {\n  if (!oldSuffix) {\n    return string + newSuffix;\n  }\n  if (string.slice(-oldSuffix.length) != oldSuffix) {\n    throw Error(\"string \".concat(JSON.stringify(string), \" doesn't end with suffix \").concat(JSON.stringify(oldSuffix), \"; this is a bug\"));\n  }\n  return string.slice(0, -oldSuffix.length) + newSuffix;\n}\nfunction removePrefix(string, oldPrefix) {\n  return replacePrefix(string, oldPrefix, '');\n}\nfunction removeSuffix(string, oldSuffix) {\n  return replaceSuffix(string, oldSuffix, '');\n}\nfunction maximumOverlap(string1, string2) {\n  return string2.slice(0, overlapCount(string1, string2));\n}\n\n// Nicked from https://stackoverflow.com/a/60422853/1709587\nfunction overlapCount(a, b) {\n  // Deal with cases where the strings differ in length\n  var startA = 0;\n  if (a.length > b.length) {\n    startA = a.length - b.length;\n  }\n  var endB = b.length;\n  if (a.length < b.length) {\n    endB = a.length;\n  }\n  // Create a back-reference for each index\n  //   that should be followed in case of a mismatch.\n  //   We only need B to make these references:\n  var map = Array(endB);\n  var k = 0; // Index that lags behind j\n  map[0] = 0;\n  for (var j = 1; j < endB; j++) {\n    if (b[j] == b[k]) {\n      map[j] = map[k]; // skip over the same character (optional optimisation)\n    } else {\n      map[j] = k;\n    }\n    while (k > 0 && b[j] != b[k]) {\n      k = map[k];\n    }\n    if (b[j] == b[k]) {\n      k++;\n    }\n  }\n  // Phase 2: use these references while iterating over A\n  k = 0;\n  for (var i = startA; i < a.length; i++) {\n    while (k > 0 && a[i] != b[k]) {\n      k = map[k];\n    }\n    if (a[i] == b[k]) {\n      k++;\n    }\n  }\n  return k;\n}\n\n/**\n * Returns true if the string consistently uses Windows line endings.\n */\nfunction hasOnlyWinLineEndings(string) {\n  return string.includes('\\r\\n') && !string.startsWith('\\n') && !string.match(/[^\\r]\\n/);\n}\n\n/**\n * Returns true if the string consistently uses Unix line endings.\n */\nfunction hasOnlyUnixLineEndings(string) {\n  return !string.includes('\\r\\n') && string.includes('\\n');\n}\n\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nvar extendedWordChars = \"a-zA-Z0-9_\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}\";\n\n// Each token is one of the following:\n// - A punctuation mark plus the surrounding whitespace\n// - A word plus the surrounding whitespace\n// - Pure whitespace (but only in the special case where this the entire text\n//   is just whitespace)\n//\n// We have to include surrounding whitespace in the tokens because the two\n// alternative approaches produce horribly broken results:\n// * If we just discard the whitespace, we can't fully reproduce the original\n//   text from the sequence of tokens and any attempt to render the diff will\n//   get the whitespace wrong.\n// * If we have separate tokens for whitespace, then in a typical text every\n//   second token will be a single space character. But this often results in\n//   the optimal diff between two texts being a perverse one that preserves\n//   the spaces between words but deletes and reinserts actual common words.\n//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640\n//   for an example.\n//\n// Keeping the surrounding whitespace of course has implications for .equals\n// and .join, not just .tokenize.\n\n// This regex does NOT fully implement the tokenization rules described above.\n// Instead, it gives runs of whitespace their own \"token\". The tokenize method\n// then handles stitching whitespace tokens onto adjacent word or punctuation\n// tokens.\nvar tokenizeIncludingWhitespace = new RegExp(\"[\".concat(extendedWordChars, \"]+|\\\\s+|[^\").concat(extendedWordChars, \"]\"), 'ug');\nvar wordDiff = new Diff();\nwordDiff.equals = function (left, right, options) {\n  if (options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n  return left.trim() === right.trim();\n};\nwordDiff.tokenize = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var parts;\n  if (options.intlSegmenter) {\n    if (options.intlSegmenter.resolvedOptions().granularity != 'word') {\n      throw new Error('The segmenter passed must have a granularity of \"word\"');\n    }\n    parts = Array.from(options.intlSegmenter.segment(value), function (segment) {\n      return segment.segment;\n    });\n  } else {\n    parts = value.match(tokenizeIncludingWhitespace) || [];\n  }\n  var tokens = [];\n  var prevPart = null;\n  parts.forEach(function (part) {\n    if (/\\s/.test(part)) {\n      if (prevPart == null) {\n        tokens.push(part);\n      } else {\n        tokens.push(tokens.pop() + part);\n      }\n    } else if (/\\s/.test(prevPart)) {\n      if (tokens[tokens.length - 1] == prevPart) {\n        tokens.push(tokens.pop() + part);\n      } else {\n        tokens.push(prevPart + part);\n      }\n    } else {\n      tokens.push(part);\n    }\n    prevPart = part;\n  });\n  return tokens;\n};\nwordDiff.join = function (tokens) {\n  // Tokens being joined here will always have appeared consecutively in the\n  // same text, so we can simply strip off the leading whitespace from all the\n  // tokens except the first (and except any whitespace-only tokens - but such\n  // a token will always be the first and only token anyway) and then join them\n  // and the whitespace around words and punctuation will end up correct.\n  return tokens.map(function (token, i) {\n    if (i == 0) {\n      return token;\n    } else {\n      return token.replace(/^\\s+/, '');\n    }\n  }).join('');\n};\nwordDiff.postProcess = function (changes, options) {\n  if (!changes || options.oneChangePerToken) {\n    return changes;\n  }\n  var lastKeep = null;\n  // Change objects representing any insertion or deletion since the last\n  // \"keep\" change object. There can be at most one of each.\n  var insertion = null;\n  var deletion = null;\n  changes.forEach(function (change) {\n    if (change.added) {\n      insertion = change;\n    } else if (change.removed) {\n      deletion = change;\n    } else {\n      if (insertion || deletion) {\n        // May be false at start of text\n        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);\n      }\n      lastKeep = change;\n      insertion = null;\n      deletion = null;\n    }\n  });\n  if (insertion || deletion) {\n    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);\n  }\n  return changes;\n};\nfunction diffWords(oldStr, newStr, options) {\n  // This option has never been documented and never will be (it's clearer to\n  // just call `diffWordsWithSpace` directly if you need that behavior), but\n  // has existed in jsdiff for a long time, so we retain support for it here\n  // for the sake of backwards compatibility.\n  if ((options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {\n    return diffWordsWithSpace(oldStr, newStr, options);\n  }\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {\n  // Before returning, we tidy up the leading and trailing whitespace of the\n  // change objects to eliminate cases where trailing whitespace in one object\n  // is repeated as leading whitespace in the next.\n  // Below are examples of the outcomes we want here to explain the code.\n  // I=insert, K=keep, D=delete\n  // 1. diffing 'foo bar baz' vs 'foo baz'\n  //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'\n  //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'\n  //\n  // 2. Diffing 'foo bar baz' vs 'foo qux baz'\n  //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'\n  //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'\n  //\n  // 3. Diffing 'foo\\nbar baz' vs 'foo baz'\n  //    Prior to cleanup, we have K:'foo ' D:'\\nbar ' K:' baz'\n  //    After cleanup, we want K'foo' D:'\\nbar' K:' baz'\n  //\n  // 4. Diffing 'foo baz' vs 'foo\\nbar baz'\n  //    Prior to cleanup, we have K:'foo\\n' I:'\\nbar ' K:' baz'\n  //    After cleanup, we ideally want K'foo' I:'\\nbar' K:' baz'\n  //    but don't actually manage this currently (the pre-cleanup change\n  //    objects don't contain enough information to make it possible).\n  //\n  // 5. Diffing 'foo   bar baz' vs 'foo  baz'\n  //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'\n  //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'\n  //\n  // Our handling is unavoidably imperfect in the case where there's a single\n  // indel between keeps and the whitespace has changed. For instance, consider\n  // diffing 'foo\\tbar\\nbaz' vs 'foo baz'. Unless we create an extra change\n  // object to represent the insertion of the space character (which isn't even\n  // a token), we have no way to avoid losing information about the texts'\n  // original whitespace in the result we return. Still, we do our best to\n  // output something that will look sensible if we e.g. print it with\n  // insertions in green and deletions in red.\n\n  // Between two \"keep\" change objects (or before the first or after the last\n  // change object), we can have either:\n  // * A \"delete\" followed by an \"insert\"\n  // * Just an \"insert\"\n  // * Just a \"delete\"\n  // We handle the three cases separately.\n  if (deletion && insertion) {\n    var oldWsPrefix = deletion.value.match(/^\\s*/)[0];\n    var oldWsSuffix = deletion.value.match(/\\s*$/)[0];\n    var newWsPrefix = insertion.value.match(/^\\s*/)[0];\n    var newWsSuffix = insertion.value.match(/\\s*$/)[0];\n    if (startKeep) {\n      var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);\n      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);\n      deletion.value = removePrefix(deletion.value, commonWsPrefix);\n      insertion.value = removePrefix(insertion.value, commonWsPrefix);\n    }\n    if (endKeep) {\n      var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);\n      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);\n      deletion.value = removeSuffix(deletion.value, commonWsSuffix);\n      insertion.value = removeSuffix(insertion.value, commonWsSuffix);\n    }\n  } else if (insertion) {\n    // The whitespaces all reflect what was in the new text rather than\n    // the old, so we essentially have no information about whitespace\n    // insertion or deletion. We just want to dedupe the whitespace.\n    // We do that by having each change object keep its trailing\n    // whitespace and deleting duplicate leading whitespace where\n    // present.\n    if (startKeep) {\n      insertion.value = insertion.value.replace(/^\\s*/, '');\n    }\n    if (endKeep) {\n      endKeep.value = endKeep.value.replace(/^\\s*/, '');\n    }\n    // otherwise we've got a deletion and no insertion\n  } else if (startKeep && endKeep) {\n    var newWsFull = endKeep.value.match(/^\\s*/)[0],\n      delWsStart = deletion.value.match(/^\\s*/)[0],\n      delWsEnd = deletion.value.match(/\\s*$/)[0];\n\n    // Any whitespace that comes straight after startKeep in both the old and\n    // new texts, assign to startKeep and remove from the deletion.\n    var newWsStart = longestCommonPrefix(newWsFull, delWsStart);\n    deletion.value = removePrefix(deletion.value, newWsStart);\n\n    // Any whitespace that comes straight before endKeep in both the old and\n    // new texts, and hasn't already been assigned to startKeep, assign to\n    // endKeep and remove from the deletion.\n    var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);\n    deletion.value = removeSuffix(deletion.value, newWsEnd);\n    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);\n\n    // If there's any whitespace from the new text that HASN'T already been\n    // assigned, assign it to the start:\n    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));\n  } else if (endKeep) {\n    // We are at the start of the text. Preserve all the whitespace on\n    // endKeep, and just remove whitespace from the end of deletion to the\n    // extent that it overlaps with the start of endKeep.\n    var endKeepWsPrefix = endKeep.value.match(/^\\s*/)[0];\n    var deletionWsSuffix = deletion.value.match(/\\s*$/)[0];\n    var overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);\n    deletion.value = removeSuffix(deletion.value, overlap);\n  } else if (startKeep) {\n    // We are at the END of the text. Preserve all the whitespace on\n    // startKeep, and just remove whitespace from the start of deletion to\n    // the extent that it overlaps with the end of startKeep.\n    var startKeepWsSuffix = startKeep.value.match(/\\s*$/)[0];\n    var deletionWsPrefix = deletion.value.match(/^\\s*/)[0];\n    var _overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);\n    deletion.value = removePrefix(deletion.value, _overlap);\n  }\n}\nvar wordWithSpaceDiff = new Diff();\nwordWithSpaceDiff.tokenize = function (value) {\n  // Slightly different to the tokenizeIncludingWhitespace regex used above in\n  // that this one treats each individual newline as a distinct tokens, rather\n  // than merging them into other surrounding whitespace. This was requested\n  // in https://github.com/kpdecker/jsdiff/issues/180 &\n  //    https://github.com/kpdecker/jsdiff/issues/211\n  var regex = new RegExp(\"(\\\\r?\\\\n)|[\".concat(extendedWordChars, \"]+|[^\\\\S\\\\n\\\\r]+|[^\").concat(extendedWordChars, \"]\"), 'ug');\n  return value.match(regex) || [];\n};\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordWithSpaceDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n  return defaults;\n}\n\nvar lineDiff = new Diff();\nlineDiff.tokenize = function (value, options) {\n  if (options.stripTrailingCr) {\n    // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n    value = value.replace(/\\r\\n/g, '\\n');\n  }\n  var retLines = [],\n    linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n  // Ignore the final empty token that occurs if the string ends with a new line\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  }\n\n  // Merge the content and line separators into single tokens\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n    if (i % 2 && !options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      retLines.push(line);\n    }\n  }\n  return retLines;\n};\nlineDiff.equals = function (left, right, options) {\n  // If we're ignoring whitespace, we need to normalise lines by stripping\n  // whitespace before checking equality. (This has an annoying interaction\n  // with newlineIsToken that requires special handling: if newlines get their\n  // own token, then we DON'T want to trim the *newline* tokens down to empty\n  // strings, since this would cause us to treat whitespace-only line content\n  // as equal to a separator between lines, which would be weird and\n  // inconsistent with the documented behavior of the options.)\n  if (options.ignoreWhitespace) {\n    if (!options.newlineIsToken || !left.includes('\\n')) {\n      left = left.trim();\n    }\n    if (!options.newlineIsToken || !right.includes('\\n')) {\n      right = right.trim();\n    }\n  } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {\n    if (left.endsWith('\\n')) {\n      left = left.slice(0, -1);\n    }\n    if (right.endsWith('\\n')) {\n      right = right.slice(0, -1);\n    }\n  }\n  return Diff.prototype.equals.call(this, left, right, options);\n};\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\n\n// Kept for backwards compatibility. This is a rather arbitrary wrapper method\n// that just calls `diffLines` with `ignoreWhitespace: true`. It's confusing to\n// have two ways to do exactly the same thing in the API, so we no longer\n// document this one (library users should explicitly use `diffLines` with\n// `ignoreWhitespace: true` instead) but we keep it around to maintain\n// compatibility with code that used old versions.\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar jsonDiff = new Diff();\n// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function (value, options) {\n  var undefinedReplacement = options.undefinedReplacement,\n    _options$stringifyRep = options.stringifyReplacer,\n    stringifyReplacer = _options$stringifyRep === void 0 ? function (k, v) {\n      return typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _options$stringifyRep;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\njsonDiff.equals = function (left, right, options) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'), options);\n};\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n}\n\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n  var i;\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n  var canonicalizedObj;\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    var sortedKeys = [],\n      _key;\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (Object.prototype.hasOwnProperty.call(obj, _key)) {\n        sortedKeys.push(_key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction unixToWin(patch) {\n  if (Array.isArray(patch)) {\n    return patch.map(unixToWin);\n  }\n  return _objectSpread2(_objectSpread2({}, patch), {}, {\n    hunks: patch.hunks.map(function (hunk) {\n      return _objectSpread2(_objectSpread2({}, hunk), {}, {\n        lines: hunk.lines.map(function (line, i) {\n          var _hunk$lines;\n          return line.startsWith('\\\\') || line.endsWith('\\r') || (_hunk$lines = hunk.lines[i + 1]) !== null && _hunk$lines !== void 0 && _hunk$lines.startsWith('\\\\') ? line : line + '\\r';\n        })\n      });\n    })\n  });\n}\nfunction winToUnix(patch) {\n  if (Array.isArray(patch)) {\n    return patch.map(winToUnix);\n  }\n  return _objectSpread2(_objectSpread2({}, patch), {}, {\n    hunks: patch.hunks.map(function (hunk) {\n      return _objectSpread2(_objectSpread2({}, hunk), {}, {\n        lines: hunk.lines.map(function (line) {\n          return line.endsWith('\\r') ? line.substring(0, line.length - 1) : line;\n        })\n      });\n    })\n  });\n}\n\n/**\n * Returns true if the patch consistently uses Unix line endings (or only involves one line and has\n * no line endings).\n */\nfunction isUnix(patch) {\n  if (!Array.isArray(patch)) {\n    patch = [patch];\n  }\n  return !patch.some(function (index) {\n    return index.hunks.some(function (hunk) {\n      return hunk.lines.some(function (line) {\n        return !line.startsWith('\\\\') && line.endsWith('\\r');\n      });\n    });\n  });\n}\n\n/**\n * Returns true if the patch uses Windows line endings and only Windows line endings.\n */\nfunction isWin(patch) {\n  if (!Array.isArray(patch)) {\n    patch = [patch];\n  }\n  return patch.some(function (index) {\n    return index.hunks.some(function (hunk) {\n      return hunk.lines.some(function (line) {\n        return line.endsWith('\\r');\n      });\n    });\n  }) && patch.every(function (index) {\n    return index.hunks.every(function (hunk) {\n      return hunk.lines.every(function (line, i) {\n        var _hunk$lines2;\n        return line.startsWith('\\\\') || line.endsWith('\\r') || ((_hunk$lines2 = hunk.lines[i + 1]) === null || _hunk$lines2 === void 0 ? void 0 : _hunk$lines2.startsWith('\\\\'));\n      });\n    });\n  });\n}\n\nfunction parsePatch(uniDiff) {\n  var diffstr = uniDiff.split(/\\n/),\n    list = [],\n    i = 0;\n  function parseIndex() {\n    var index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      var line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      }\n\n      // Diff index\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n      if (/^(Index:\\s|diff\\s|\\-\\-\\-\\s|\\+\\+\\+\\s|===================================================================)/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line) {\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)\\r?$/.exec(diffstr[i]);\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n      chunkHeaderLine = diffstr[i++],\n      chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: []\n    };\n\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n    var addCount = 0,\n      removeCount = 0;\n    for (; i < diffstr.length && (removeCount < hunk.oldLines || addCount < hunk.newLines || (_diffstr$i = diffstr[i]) !== null && _diffstr$i !== void 0 && _diffstr$i.startsWith('\\\\')); i++) {\n      var _diffstr$i;\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        throw new Error(\"Hunk at line \".concat(chunkHeaderIndex + 1, \" contained invalid line \").concat(diffstr[i]));\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform sanity checking\n    if (addCount !== hunk.newLines) {\n      throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n    }\n    if (removeCount !== hunk.oldLines) {\n      throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n    }\n    return hunk;\n  }\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n  return list;\n}\n\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator (start, minLine, maxLine) {\n  var wantForward = true,\n    backwardExhausted = false,\n    forwardExhausted = false,\n    localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      }\n\n      // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n      if (start + localOffset <= maxLine) {\n        return start + localOffset;\n      }\n      forwardExhausted = true;\n    }\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      }\n\n      // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n      if (minLine <= start - localOffset) {\n        return start - localOffset++;\n      }\n      backwardExhausted = true;\n      return iterator();\n    }\n\n    // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n    uniDiff = uniDiff[0];\n  }\n  if (options.autoConvertLineEndings || options.autoConvertLineEndings == null) {\n    if (hasOnlyWinLineEndings(source) && isUnix(uniDiff)) {\n      uniDiff = unixToWin(uniDiff);\n    } else if (hasOnlyUnixLineEndings(source) && isWin(uniDiff)) {\n      uniDiff = winToUnix(uniDiff);\n    }\n  }\n\n  // Apply the diff to the input\n  var lines = source.split('\\n'),\n    hunks = uniDiff.hunks,\n    compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n      return line === patchContent;\n    },\n    fuzzFactor = options.fuzzFactor || 0,\n    minLine = 0;\n  if (fuzzFactor < 0 || !Number.isInteger(fuzzFactor)) {\n    throw new Error('fuzzFactor must be a non-negative integer');\n  }\n\n  // Special case for empty patch.\n  if (!hunks.length) {\n    return source;\n  }\n\n  // Before anything else, handle EOFNL insertion/removal. If the patch tells us to make a change\n  // to the EOFNL that is redundant/impossible - i.e. to remove a newline that's not there, or add a\n  // newline that already exists - then we either return false and fail to apply the patch (if\n  // fuzzFactor is 0) or simply ignore the problem and do nothing (if fuzzFactor is >0).\n  // If we do need to remove/add a newline at EOF, this will always be in the final hunk:\n  var prevLine = '',\n    removeEOFNL = false,\n    addEOFNL = false;\n  for (var i = 0; i < hunks[hunks.length - 1].lines.length; i++) {\n    var line = hunks[hunks.length - 1].lines[i];\n    if (line[0] == '\\\\') {\n      if (prevLine[0] == '+') {\n        removeEOFNL = true;\n      } else if (prevLine[0] == '-') {\n        addEOFNL = true;\n      }\n    }\n    prevLine = line;\n  }\n  if (removeEOFNL) {\n    if (addEOFNL) {\n      // This means the final line gets changed but doesn't have a trailing newline in either the\n      // original or patched version. In that case, we do nothing if fuzzFactor > 0, and if\n      // fuzzFactor is 0, we simply validate that the source file has no trailing newline.\n      if (!fuzzFactor && lines[lines.length - 1] == '') {\n        return false;\n      }\n    } else if (lines[lines.length - 1] == '') {\n      lines.pop();\n    } else if (!fuzzFactor) {\n      return false;\n    }\n  } else if (addEOFNL) {\n    if (lines[lines.length - 1] != '') {\n      lines.push('');\n    } else if (!fuzzFactor) {\n      return false;\n    }\n  }\n\n  /**\n   * Checks if the hunk can be made to fit at the provided location with at most `maxErrors`\n   * insertions, substitutions, or deletions, while ensuring also that:\n   * - lines deleted in the hunk match exactly, and\n   * - wherever an insertion operation or block of insertion operations appears in the hunk, the\n   *   immediately preceding and following lines of context match exactly\n   *\n   * `toPos` should be set such that lines[toPos] is meant to match hunkLines[0].\n   *\n   * If the hunk can be applied, returns an object with properties `oldLineLastI` and\n   * `replacementLines`. Otherwise, returns null.\n   */\n  function applyHunk(hunkLines, toPos, maxErrors) {\n    var hunkLinesI = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var lastContextLineMatched = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var patchedLines = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n    var patchedLinesLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var nConsecutiveOldContextLines = 0;\n    var nextContextLineMustMatch = false;\n    for (; hunkLinesI < hunkLines.length; hunkLinesI++) {\n      var hunkLine = hunkLines[hunkLinesI],\n        operation = hunkLine.length > 0 ? hunkLine[0] : ' ',\n        content = hunkLine.length > 0 ? hunkLine.substr(1) : hunkLine;\n      if (operation === '-') {\n        if (compareLine(toPos + 1, lines[toPos], operation, content)) {\n          toPos++;\n          nConsecutiveOldContextLines = 0;\n        } else {\n          if (!maxErrors || lines[toPos] == null) {\n            return null;\n          }\n          patchedLines[patchedLinesLength] = lines[toPos];\n          return applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1);\n        }\n      }\n      if (operation === '+') {\n        if (!lastContextLineMatched) {\n          return null;\n        }\n        patchedLines[patchedLinesLength] = content;\n        patchedLinesLength++;\n        nConsecutiveOldContextLines = 0;\n        nextContextLineMustMatch = true;\n      }\n      if (operation === ' ') {\n        nConsecutiveOldContextLines++;\n        patchedLines[patchedLinesLength] = lines[toPos];\n        if (compareLine(toPos + 1, lines[toPos], operation, content)) {\n          patchedLinesLength++;\n          lastContextLineMatched = true;\n          nextContextLineMustMatch = false;\n          toPos++;\n        } else {\n          if (nextContextLineMustMatch || !maxErrors) {\n            return null;\n          }\n\n          // Consider 3 possibilities in sequence:\n          // 1. lines contains a *substitution* not included in the patch context, or\n          // 2. lines contains an *insertion* not included in the patch context, or\n          // 3. lines contains a *deletion* not included in the patch context\n          // The first two options are of course only possible if the line from lines is non-null -\n          // i.e. only option 3 is possible if we've overrun the end of the old file.\n          return lines[toPos] && (applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength + 1) || applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1)) || applyHunk(hunkLines, toPos, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength);\n        }\n      }\n    }\n\n    // Before returning, trim any unmodified context lines off the end of patchedLines and reduce\n    // toPos (and thus oldLineLastI) accordingly. This allows later hunks to be applied to a region\n    // that starts in this hunk's trailing context.\n    patchedLinesLength -= nConsecutiveOldContextLines;\n    toPos -= nConsecutiveOldContextLines;\n    patchedLines.length = patchedLinesLength;\n    return {\n      patchedLines: patchedLines,\n      oldLineLastI: toPos - 1\n    };\n  }\n  var resultLines = [];\n\n  // Search best fit offsets for each hunk based on the previous ones\n  var prevHunkOffset = 0;\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var hunk = hunks[_i];\n    var hunkResult = void 0;\n    var maxLine = lines.length - hunk.oldLines + fuzzFactor;\n    var toPos = void 0;\n    for (var maxErrors = 0; maxErrors <= fuzzFactor; maxErrors++) {\n      toPos = hunk.oldStart + prevHunkOffset - 1;\n      var iterator = distanceIterator(toPos, minLine, maxLine);\n      for (; toPos !== undefined; toPos = iterator()) {\n        hunkResult = applyHunk(hunk.lines, toPos, maxErrors);\n        if (hunkResult) {\n          break;\n        }\n      }\n      if (hunkResult) {\n        break;\n      }\n    }\n    if (!hunkResult) {\n      return false;\n    }\n\n    // Copy everything from the end of where we applied the last hunk to the start of this hunk\n    for (var _i2 = minLine; _i2 < toPos; _i2++) {\n      resultLines.push(lines[_i2]);\n    }\n\n    // Add the lines produced by applying the hunk:\n    for (var _i3 = 0; _i3 < hunkResult.patchedLines.length; _i3++) {\n      var _line = hunkResult.patchedLines[_i3];\n      resultLines.push(_line);\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunkResult.oldLineLastI + 1;\n\n    // Note the offset between where the patch said the hunk should've applied and where we\n    // applied it, so we can adjust future hunks accordingly:\n    prevHunkOffset = toPos + 1 - hunk.oldStart;\n  }\n\n  // Copy over the rest of the lines from the old text\n  for (var _i4 = minLine; _i4 < lines.length; _i4++) {\n    resultLines.push(lines[_i4]);\n  }\n  return resultLines.join('\\n');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n  var currentIndex = 0;\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options === 'function') {\n    options = {\n      callback: options\n    };\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n  if (options.newlineIsToken) {\n    throw new Error('newlineIsToken may not be used with patch-generation functions, only with diffing functions');\n  }\n  if (!options.callback) {\n    return diffLinesResultToPatch(diffLines(oldStr, newStr, options));\n  } else {\n    var _options = options,\n      _callback = _options.callback;\n    diffLines(oldStr, newStr, _objectSpread2(_objectSpread2({}, options), {}, {\n      callback: function callback(diff) {\n        var patch = diffLinesResultToPatch(diff);\n        _callback(patch);\n      }\n    }));\n  }\n  function diffLinesResultToPatch(diff) {\n    // STEP 1: Build up the patch with no \"\\ No newline at end of file\" lines and with the arrays\n    //         of lines containing trailing newline characters. We'll tidy up later...\n\n    if (!diff) {\n      return;\n    }\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n    var hunks = [];\n    var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n    var _loop = function _loop() {\n      var current = diff[i],\n        lines = current.lines || splitLines(current.value);\n      current.lines = lines;\n      if (current.added || current.removed) {\n        var _curRange;\n        // If we have previous context, start with that\n        if (!oldRangeStart) {\n          var prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        }\n\n        // Output our changes\n        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n          return (current.added ? '+' : '-') + entry;\n        })));\n\n        // Track the updated file position\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            var _curRange2;\n            // Overlapping\n            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n          } else {\n            var _curRange3;\n            // end the range and output\n            var contextSize = Math.min(lines.length, options.context);\n            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n            var _hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n            hunks.push(_hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    };\n    for (var i = 0; i < diff.length; i++) {\n      _loop();\n    }\n\n    // Step 2: eliminate the trailing `\\n` from each line of each hunk, and, where needed, add\n    //         \"\\ No newline at end of file\".\n    for (var _i = 0, _hunks = hunks; _i < _hunks.length; _i++) {\n      var hunk = _hunks[_i];\n      for (var _i2 = 0; _i2 < hunk.lines.length; _i2++) {\n        if (hunk.lines[_i2].endsWith('\\n')) {\n          hunk.lines[_i2] = hunk.lines[_i2].slice(0, -1);\n        } else {\n          hunk.lines.splice(_i2 + 1, 0, '\\\\ No newline at end of file');\n          _i2++; // Skip the line we just added, then continue iterating\n        }\n      }\n    }\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n}\nfunction formatPatch(diff) {\n  if (Array.isArray(diff)) {\n    return diff.map(formatPatch).join('\\n');\n  }\n  var ret = [];\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i];\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n  return ret.join('\\n') + '\\n';\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  var _options2;\n  if (typeof options === 'function') {\n    options = {\n      callback: options\n    };\n  }\n  if (!((_options2 = options) !== null && _options2 !== void 0 && _options2.callback)) {\n    var patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n    if (!patchObj) {\n      return;\n    }\n    return formatPatch(patchObj);\n  } else {\n    var _options3 = options,\n      _callback2 = _options3.callback;\n    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, _objectSpread2(_objectSpread2({}, options), {}, {\n      callback: function callback(patchObj) {\n        if (!patchObj) {\n          _callback2();\n        } else {\n          _callback2(formatPatch(patchObj));\n        }\n      }\n    }));\n  }\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\n/**\n * Split `text` into an array of lines, including the trailing newline character (where present)\n */\nfunction splitLines(text) {\n  var hasTrailingNl = text.endsWith('\\n');\n  var result = text.split('\\n').map(function (line) {\n    return line + '\\n';\n  });\n  if (hasTrailingNl) {\n    result.pop();\n  } else {\n    result.push(result.pop().slice(0, -1));\n  }\n  return result;\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n    oldLines = _calcOldNewLineCount.oldLines,\n    newLines = _calcOldNewLineCount.newLines;\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n  ret.hunks = [];\n  var mineIndex = 0,\n    theirsIndex = 0,\n    mineOffset = 0,\n    theirsOffset = 0;\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n      theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n  return ret;\n}\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n  return param;\n}\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n    their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    };\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n      theirCurrent = their.lines[their.index];\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines;\n      // Mine inserted\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2;\n      // Theirs inserted\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n    theirChanges = collectChange(their);\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n    return;\n  }\n  conflict(hunk, myChanges, theirChanges);\n}\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n    theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\nfunction collectChange(state) {\n  var ret = [],\n    operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n    merged = [],\n    matchIndex = 0,\n    contextChanges = false,\n    conflicted = false;\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n      match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n  if (conflicted) {\n    return changes;\n  }\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n  state.index += delta;\n  return true;\n}\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\n\nfunction reversePatch(structuredPatch) {\n  if (Array.isArray(structuredPatch)) {\n    return structuredPatch.map(reversePatch).reverse();\n  }\n  return _objectSpread2(_objectSpread2({}, structuredPatch), {}, {\n    oldFileName: structuredPatch.newFileName,\n    oldHeader: structuredPatch.newHeader,\n    newFileName: structuredPatch.oldFileName,\n    newHeader: structuredPatch.oldHeader,\n    hunks: structuredPatch.hunks.map(function (hunk) {\n      return {\n        oldLines: hunk.newLines,\n        oldStart: hunk.newStart,\n        newLines: hunk.oldLines,\n        newStart: hunk.oldStart,\n        lines: hunk.lines.map(function (l) {\n          if (l.startsWith('-')) {\n            return \"+\".concat(l.slice(1));\n          }\n          if (l.startsWith('+')) {\n            return \"-\".concat(l.slice(1));\n          }\n          return l;\n        })\n      };\n    })\n  });\n}\n\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n    change,\n    operation;\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n    ret.push([operation, change.value]);\n  }\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n    ret.push(escapeHTML(change.value));\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n  return ret.join('');\n}\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, formatPatch, merge, parsePatch, reversePatch, structuredPatch };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}